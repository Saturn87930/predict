<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>🛰</title>
    <style>
        :root {
            --primary-color: #4CAF50;
            --secondary-color: #f0f0f0;
            --text-color: #333;
            --hover-color: #45a049;
            --font-family: 'Arial', sans-serif;
        }

                /* 19:00~07:00 (夜间) */
        .night {
            background-color: #494953;
            color: #ffffbc;
        }

        /* 其余时间 (白天) */
        .day {
            background-color: #2e71d1;
            color: #ffffbc;
        }
        body {
            font-family: var(--font-family);
            background-color: var(--secondary-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

                    #made {
    margin-top: 20px; /* Increases the space above the element */
    font-size: 14px;  /* Optional: Adjust font size */
}

        h1 {
            margin-bottom: 20px;
        }


                .lang-toggle {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 14px;
        }
        .lang-toggle a {
            margin: 0 5px;
            text-decoration: none;
            color: #919191;
        }
        .lang-toggle a.active {
            font-weight: bold;
            color: black;
        }

        @media (prefers-color-scheme: dark) {
    .lang-toggle a.active {
            font-weight: bold;
            color: white;
    }
}


.button {
    padding: 8px 15px;
    border: none;
    border-radius: 5px;
    background-color: var(--primary-color);
    color: white;
    font-size: 16px;
    cursor: pointer;
    transition: background-color 0.3s;
    margin-top: 10px;  /* 上间距 */
        margin-bottom: 10px;  /* 上间距 */

}

        .button:hover {
            background-color: var(--hover-color);
        }

        .custom-dropdown {
    position: relative;
    width: 85%;
        }

        .custom-dropdown button {
            width: 100%;
            height: 40px;
            text-align: left;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            font-size: 14px;
            cursor: pointer;
        }

        .dropdown-item {
    padding: 5px;
    cursor: pointer;
}

.dropdown-item:hover {
    background-color: #f0f0f0;
}



        .dropdown-list {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background-color: white;
    border: 1px solid #ccc;
    max-height: 400px;
    overflow-y: auto;
    z-index: 1000;
    display: none; /* 默认隐藏 */
        }
@media (prefers-color-scheme: dark) {
    .dropdown-list {
        background-color: #333; /* 深色模式背景 */
        border: 1px solid #555;
    }
}
        .dropdown-list div {
            padding: 10px;
            cursor: pointer;
            font-size: 14px;
        }

        .dropdown-list div:hover {
            background-color: var(--primary-color);
            color: white;
        }

        #searchInput {
            width: 100%;
            /*max-width: 300px;*/
            padding: 10px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-bottom: 10px;
            box-sizing: border-box;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }



        #satelliteLinkContainer {
            margin-top: 20px;
            max-width: 300px;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --primary-color: #3e8e41;
                --secondary-color: #2c2c2c;
                --text-color: #ddd;
                --hover-color: #2e7033;
            }

            body {
                color: var(--text-color);
            }

            .custom-dropdown button, 
            #searchInput, 
            #passInfo {
                background-color: #444;
                border: 1px solid #555;
                color: var(--text-color);
            }

            .dropdown-list div:hover {
                background-color: var(--hover-color);
                color: white;
            }



        }
    </style>
</head>
<body>
    <h1>🛰</h1>


        <!-- 语言切换按钮 -->
    <div class="lang-toggle">
        <a href="#" id="langZH" class="active">ZH</a> | <a href="#" id="langEN">EN</a>
    </div>


    <!--<button id="getLocation" class="button">获取位置</button>-->
    

<div class="custom-dropdown">
    <input type="text" id="searchInput" placeholder="搜索卫星..." />
    <div class="dropdown-list" id="satelliteDropdown"></div>
</div>

    <!--<input type="text" id="searchInput" placeholder="搜索卫星..." />-->

<div id="location" style="align-self: left;"></div>

    <div class="checkbox-container">
        <label for="timeFilter"  id="timeFilterLabel" ></label>
        <input type="checkbox" id="timeFilter">
    </div>

    <div class="elevation-filter">
    <label for="elevationThreshold"  id="elevationThresholdLabel"></label>
    <select id="elevationThreshold">
        <option value="0">0°</option>
        <option value="10">10°</option>
        <option value="15" selected>15°</option>
        <option value="20">20°</option>
        <option value="25">25°</option>
        <option value="30">30°</option>
        <option value="35">35°</option>
        <option value="40">40°</option>
        <option value="45">45°</option>
    </select>
</div>

    <button id="calculatePass" class="button">计算过境信息</button>
<div id="notesInfo" style="font-weight: bold;"></div>
<div id="passInfo" style="font-weight: bold;"></div>


    <div id="made">Made with ❤ by troilus</div>


    <script src="satellite.js"></script>

    <script>


                // 定义语言内容
        const translations = {
            zh: {
                location: "位置：${latitude}, ${longitude}",
                locationDefault: "位置信息：未获取",
                timeFilterLabel: "仅计算 19:00 ~ 23:59",
                elevationThresholdLabel: "最高点仰角≥",
                notesInfo: "点击仰角：对星<br>点击日期：加入日历提醒",
                placeholder: "搜索卫星...",
                calculatePass:"计算过境信息",
                                 noTLE:"无TLE信息",
                                 unabletocalc:"请选择卫星并确认已定位",

        noPassesInfo: "当前条件下未来3天内没有过境信息",
        tableHeaders: {
            date: "日期",
            start: "开始",
            highest: "最高仰角",
            end: "结束",
            time: "时间",
            azimuth: "方位",
            elevation: "仰角",
            nolocation:"无法获取位置，请检查权限设置"
        }

        },

            en: {
                location: "Location: ${latitude}, ${longitude}",
                locationDefault: "Location: Not Retrieved",
                timeFilterLabel: "Calculate Only from 19:00 ~ 23:59",
                elevationThresholdLabel: "MAX. Elevation ≥",
                notesInfo: "Click the El to view the orbit page<br>Click the Date to add the event to calendar",
                placeholder: "Search satellites...",
                 calculatePass:"Calculate",
                                 noTLE:"TLE not found",
                                  unabletocalc:"Please select a satellite and confirm that the location has been determined",
                   noPassesInfo: "No passes found for the next 3 days under the current conditions",
        tableHeaders: {
            date: "Date",
            start: "Start",
            highest: "Max. El",
            end: "End",
            time: "Time",
            azimuth: "Az",
            elevation: "El",
            nolocation:"Unable to access location, please check the permission setting"
        }
        }
        };

        // 设置默认语言
        let currentLang = 'zh';
        localStorage.setItem('lang', currentLang);

        // 更新 placeholder 内容
function updatePlaceholder() {
    const searchInput = document.getElementById('searchInput');
    searchInput.placeholder = translations[currentLang].placeholder;
}


function updateTable() {
    let html = `
        <table border="1" style="border-collapse: collapse; width: 100%; text-align: center;">
            <thead>
                <tr>
                    <th rowspan="2">${translations[currentLang].table.date}</th>
                    <th rowspan="2">${translations[currentLang].table.start}</th>
                    <th colspan="3">${translations[currentLang].table.highestPoint}</th>
                    <th rowspan="2">${translations[currentLang].table.end}</th>
                </tr>
                <tr>
                    <th>${translations[currentLang].table.time}</th>
                    <th>${translations[currentLang].table.azimuth}</th>
                    <th>${translations[currentLang].table.elevation}</th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
    `;

    document.getElementById('tableContainer').innerHTML = html;
}


function updateTableHeaders(lang) {
    const passInfoDiv = document.getElementById('passInfo');
        const calculated  =  localStorage.getItem('calculated');
    
    // 检查是否存在表格
    const table = passInfoDiv.getElementsByTagName('table')[0];
    if (table) {
        // 如果表格存在，更新表头文本
        const headers = table.getElementsByTagName('th');
        
        headers[0].textContent = translations[lang].tableHeaders.date;
        headers[1].textContent = translations[lang].tableHeaders.start;
        headers[2].textContent = translations[lang].tableHeaders.highest;
        headers[3].textContent = translations[lang].tableHeaders.end;
        headers[4].textContent = translations[lang].tableHeaders.time;        
        headers[5].textContent = translations[lang].tableHeaders.azimuth;
        headers[6].textContent = translations[lang].tableHeaders.elevation;

    } else if (calculated == 1) {
        // 如果没有表格，更新显示的文本
        passInfoDiv.innerHTML = `<p>${translations[lang].noPassesInfo}</p>`;
    }
}

                // 初始化页面内容
        function updateContent(lang) {

                                    if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(function(position) {
                    const latitude = position.coords.latitude;
                    const longitude = position.coords.longitude;
                    const latitudefix = position.coords.latitude.toFixed(2);
                    const longitudefix = position.coords.longitude.toFixed(2);
                    const altitude = position.coords.altitude;
                    const accuracy = position.coords.accuracy.toFixed(1);
                    localStorage.setItem('latitude', latitude);
                    localStorage.setItem('longitude', longitude);
                    localStorage.setItem('altitude', altitude);




    const locationText = translations[currentLang].location
        .replace('${latitude}', latitudefix)
        .replace('${longitude}', longitudefix);

    document.getElementById('location').textContent = locationText;
                }, function(error) {
                    document.getElementById('location').textContent = translations[currentLang].nolocation

                });
            } else {
                document.getElementById('location').textContent = '浏览器不支持地理定位。';
            }



            document.getElementById('location').textContent = translations[lang].location;
            document.getElementById('timeFilterLabel').textContent = translations[lang].timeFilterLabel;
            document.getElementById('elevationThresholdLabel').textContent = translations[lang].elevationThresholdLabel;

            document.getElementById('calculatePass').textContent = translations[lang].calculatePass;



        const notesElement = document.getElementById('notesInfo');
        if (notesElement.innerHTML.trim() !== '') {
            notesElement.innerHTML = translations[currentLang].notesInfo;
        }





            // 更新语言切换按钮的样式
            document.getElementById('langZH').classList.toggle('active', lang === 'zh');
            document.getElementById('langEN').classList.toggle('active', lang === 'en');
        }

        // 切换语言事件
        document.getElementById('langZH').addEventListener('click', (e) => {
            e.preventDefault();
            currentLang = 'zh';
            updateContent(currentLang);
            updatePlaceholder(); // 更新 placeholder 文本
            updateTableHeaders(currentLang);
                                localStorage.setItem('lang', currentLang);
        });

        document.getElementById('langEN').addEventListener('click', (e) => {
            e.preventDefault();
            currentLang = 'en';
            updateContent(currentLang);
            updatePlaceholder(); // 更新 placeholder 文本
            updateTableHeaders(currentLang);
            localStorage.setItem('lang', currentLang);

        });

        // 初始化页面
        updateContent(currentLang);
        updatePlaceholder(); // 更新 placeholder 文本








        let satellites = [];


        window.addEventListener('load', function() {
            document.getElementById('location').textContent = translations[currentLang].locationDefault;
            localStorage.removeItem('selectedSatelliteName');
            localStorage.removeItem('calculated');
            localStorage.removeItem('selectedSatelliteTLE1');
            localStorage.removeItem('selectedSatelliteTLE2');
            localStorage.removeItem('selectedorbit');


                        if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(function(position) {
                    const latitude = position.coords.latitude;
                    const longitude = position.coords.longitude;
                    const latitudefix = position.coords.latitude.toFixed(2);
                    const longitudefix = position.coords.longitude.toFixed(2);
                    const altitude = position.coords.altitude;
                    const accuracy = position.coords.accuracy.toFixed(1);
                    localStorage.setItem('latitude', latitude);
                    localStorage.setItem('longitude', longitude);
                    localStorage.setItem('altitude', altitude);





    const locationText = translations[currentLang].location
        .replace('${latitude}', latitudefix)
        .replace('${longitude}', longitudefix);

    document.getElementById('location').textContent = locationText;
                }, function(error) {
                    document.getElementById('location').textContent = '无法获取位置，请检查权限设置。';
                });
            } else {
                document.getElementById('location').textContent = '浏览器不支持地理定位。';
            }




            //fetch('https://c0rs.xanyi.eu.org/?https://r4uab.ru/satonline.txt')
            fetch('/satonline.txt')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('网络响应失败');
                    }
                    return response.text();
                })
                .then(data => {
                    satellites = parseSatellitesData(data);

                    localStorage.setItem('satellites', JSON.stringify(satellites));
                    populateDropdown(satellites);
                })
                .catch(error => {
                    console.error('无法加载文件:', error);
                });
        });

function parseSatellitesData(data) {
            const lines = data.split('\n');
            const satellites = [];
            let currentSatellite = null;

            lines.forEach(line => {
                if (line.startsWith('1') || line.startsWith('2')) {
                    if (currentSatellite) {
                        currentSatellite.tle.push(line);
                    }
                } else if (line.trim() !== '') {
                    if (currentSatellite) {
                        satellites.push(currentSatellite);
                    }
                    currentSatellite = { name: line.trim(), tle: [] };
                }
            });

            if (currentSatellite) {
                satellites.push(currentSatellite);
            }

            return satellites;
        }

function populateDropdown(satellites) {
    const searchInput = document.getElementById('searchInput');
    const dropdown = document.getElementById('satelliteDropdown');

    // 初始化下拉菜单
    function renderDropdown(filteredSatellites) {
        dropdown.innerHTML = ''; // 清空列表
        filteredSatellites.forEach(satellite => {
            const div = document.createElement('div');
            div.textContent = satellite.name;
            div.classList.add('dropdown-item');
            div.addEventListener('click', function () {
                searchInput.value = satellite.name; // 将选择的值填入输入框
                dropdown.style.display = 'none'; // 隐藏下拉菜单

                // 获取并存储卫星数据
                const noradId = satellite.tle[1].split(' ')[1];
                localStorage.setItem('selectedSatelliteName', satellite.name);
                localStorage.setItem('selectedSatelliteTLE1', satellite.tle[0]);
                localStorage.setItem('selectedSatelliteTLE2', satellite.tle[1]);
            });
            dropdown.appendChild(div);
        });
        dropdown.style.display = filteredSatellites.length ? 'block' : 'none';
    }

    // 监听搜索输入
    searchInput.addEventListener('input', function () {
        const query = searchInput.value.toLowerCase();
        const filteredSatellites = satellites.filter(satellite =>
            satellite.name.toLowerCase().includes(query)
        );
        renderDropdown(filteredSatellites);
    });


        // 监听点击搜索框展开下拉菜单并选中文字
    searchInput.addEventListener('click', function () {
        searchInput.select(); // 选中所有文字
        renderDropdown(satellites); // 展开下拉菜单显示所有选项
    });

    // 初始化时加载所有选项
    renderDropdown(satellites);
}

        document.getElementById('searchInput').addEventListener('input', function() {
            const searchValue = this.value.toLowerCase();
            const dropdown = document.getElementById('satelliteDropdown');
            const options = dropdown.querySelectorAll('div');
            options.forEach(option => {
                const text = option.textContent.toLowerCase();
                if (text.includes(searchValue)) {
                    option.style.display = ''; // Show matching options
                } else {
                    option.style.display = 'none'; // Hide non-matching options
                }
            });
        });

        /*document.getElementById('dropdownButton').addEventListener('click', function() {
            const dropdown = document.getElementById('satelliteDropdown');
            dropdown.style.display = (dropdown.style.display === 'block') ? 'none' : 'block';
        });*/

        document.getElementById('calculatePass').addEventListener('click', function() {
            const satelliteName = localStorage.getItem('selectedSatelliteName')





            const locationText = document.getElementById('location').textContent;
            const match = locationText.match(/(位置：|Location: )([\-0-9.]+), ([\-0-9.]+)/);

            const timeFilterChecked = document.getElementById('timeFilter').checked;
  

            if (satelliteName && match) {
            const latitude = parseFloat(localStorage.getItem('latitude'));
            const longitude = parseFloat(localStorage.getItem('longitude'));

                const altitude = parseFloat(localStorage.getItem('altitude'));

                const satellites = JSON.parse(localStorage.getItem('satellites'));
                const satelliteinfo = satellites.find(sat => sat.name === satelliteName);

                if (!satelliteinfo) {
                    document.getElementById('passInfo').innerHTML = translations[currentLang].noTLE;
                    return;
                }

                const satrec = satellite.twoline2satrec(satelliteinfo.tle[0], satelliteinfo.tle[1]);
                           
                const currentTime = new Date();
                const passes = calculatePasses(satrec, latitude, longitude, altitude, currentTime, timeFilterChecked);

                const groupedPasses = groupPasses(passes);
                const savedSatelliteDataToLocalStorage=saveSatelliteDataToLocalStorage(groupedPasses, satelliteName)
                document.getElementById('passInfo').innerHTML = formatGroupedPassesToHTML(groupedPasses);
            } else {
                document.getElementById('passInfo').innerHTML =translations[currentLang].unabletocalc;
            }
        });

function calculatePasses(satrec, latitude, longitude, altitude, currentTime, filterNightTime) {
    localStorage.setItem('calculated', '1');
    const passes = [];
    const observerGd = {
        latitude: satellite.degreesToRadians(latitude),
        longitude: satellite.degreesToRadians(longitude),
        height: 0
    };

    const endTime = new Date(currentTime.getTime() + 3 * 24 * 60 * 60 * 1000);
    const timeStep = 1 * 1000; // 1秒步长（单位：毫秒）

    for (let time = currentTime.getTime() - 60 * 60 * 1000; time <= endTime.getTime(); time += timeStep) {
        const passTime = new Date(time);

        const positionAndVelocity = satellite.propagate(satrec, passTime);
        if (positionAndVelocity && positionAndVelocity.position) {
            const gmst = satellite.gstime(passTime);

            const lookAngles = satellite.ecfToLookAngles(
                observerGd,
                satellite.eciToEcf(positionAndVelocity.position, gmst)
            );

            if (lookAngles) {
                const elevationDegrees = satellite.radiansToDegrees(lookAngles.elevation);

                // 仰角大于 0 度的记录添加到 passes
                if (elevationDegrees > 0) {
                    const pass = {
                        time: passTime,
                        azimuth: satellite.radiansToDegrees(lookAngles.azimuth),
                        elevation: elevationDegrees,
                    };

                    if (filterNightTime) {
                        const passHour = passTime.getHours();
                        if (passHour < 19 || passHour >= 24) {
                            continue; // 跳过夜间范围外的记录
                        }
                    }

                    passes.push(pass);
                }
            }
        }
    }

    return passes;
}

function groupPasses(passes) {
    const groupedPasses = [];
    let currentPass = null;
    let hasAboveThreshold  = false; // 是否出现过仰角 >= 15 的点
        const elevationThreshold = parseFloat(document.getElementById('elevationThreshold').value);


    passes.forEach((pass, index) => {
        if (!currentPass) {
            // 初始化分组，当仰角从 0 度变为正值时开始记录
            if (pass.elevation > 0) {
                currentPass = { entry: pass, highest: pass, exit: pass };
                hasAboveThreshold  = pass.elevation >= elevationThreshold; // 标记是否达到 15 度
            }
        } else {
            const timeDifference = (new Date(pass.time) - new Date(currentPass.exit.time)) / 1000;

            if (pass.elevation > 0 && timeDifference <= 600) { 
                // 更新出口点
                currentPass.exit = pass;

                // 更新最高点
                if (pass.elevation > currentPass.highest.elevation) {
                    currentPass.highest = pass;
                }

                // 标记是否达到 15 度
                if (pass.elevation >= elevationThreshold) {
                    hasAboveThreshold  = true;
                }
            } else if (pass.elevation > 0) {
                // 保存当前分组
                if (hasAboveThreshold ) {
                    groupedPasses.push(currentPass);
                }

                // 开始新分组
                currentPass = { entry: pass, highest: pass, exit: pass };
                hasAboveThreshold = pass.elevation >= elevationThreshold;
            } else {
                // 当仰角回到 0 度时结束分组
                if (hasAboveThreshold) {
                    groupedPasses.push(currentPass);
                }
                currentPass = null;
                hasAboveThreshold = false;
            }
        }

        // 如果是最后一个点，强制结束当前分组
        if (index === passes.length - 1 && currentPass && hasAboveThreshold) {
            groupedPasses.push(currentPass);
        }
    });

    return groupedPasses;
}


function saveSatelliteDataToLocalStorage(groupedPasses, satelliteName) {

    const satelliteData = groupedPasses.map((pass, index) => {
        return {
            satelliteName: satelliteName,
            entryTime: pass.entry?.time ? new Date(pass.entry.time): "未知时间",
            entryAzimuth: pass.entry?.azimuth ? pass.entry.azimuth.toFixed(2) : "未知",
            highestTime: pass.highest?.time ? new Date(pass.highest.time): "未知时间",
            highestAzimuth: pass.highest?.azimuth ? pass.highest.azimuth.toFixed(2) : "未知",
            highestElevation: pass.highest?.elevation ? pass.highest.elevation.toFixed(2) : "未知",
            exitTime: pass.exit?.time ? new Date(pass.exit.time):"未知时间",
            exitAzimuth: pass.exit?.azimuth ? pass.exit.azimuth.toFixed(2) : "未知"
        };
    });

    // 使用卫星名称作为键，将数据存储到 localStorage
    localStorage.setItem('selectedorbit', JSON.stringify(satelliteData));
}






function formatGroupedPassesToHTML(groupedPasses) {

    const satelliteName = localStorage.getItem('selectedSatelliteName');

    if (groupedPasses.length === 0 ) {
        // Hide the "notesInfo" div on the page
        document.getElementById("notesInfo").style.display = "none";
        
        return `<p>${translations[currentLang].noPassesInfo}</p>`;
    } else {
        // Show the "notesInfo" div again if there are grouped passes
        document.getElementById("notesInfo").style.display = "block";
        
        // Continue with the regular pass formatting
        // Add your logic for formatting passes here, if any
    }

    let html = `
        <table border="1" style="border-collapse: collapse; width: 100%; text-align: center;">
            <thead>
                <tr>
                    <th rowspan="2">${translations[currentLang].tableHeaders.date}</th>
                    <th rowspan="2">${translations[currentLang].tableHeaders.start}</th>
                    <th colspan="3">${translations[currentLang].tableHeaders.highest}</th>
                    <th rowspan="2">${translations[currentLang].tableHeaders.end}</th>
                </tr>
                <tr>
                    <th>${translations[currentLang].tableHeaders.time}</th>
                    <th>${translations[currentLang].tableHeaders.azimuth}</th>
                    <th>${translations[currentLang].tableHeaders.elevation}</th>
                </tr>
            </thead>
            <tbody>
    `;

    groupedPasses.forEach((pass, index) => {
        const entrydate = pass.entry?.time ? new Date(pass.entry.time).toLocaleDateString('zh-CN', { month: '2-digit', day: '2-digit' }) : "未知时间";
        const entryTime = pass.entry?.time ? new Date(pass.entry.time).toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : "未知时间";
        const entryAzimuth = typeof pass.entry?.azimuth === "number" ? `${pass.entry.azimuth.toFixed(2)}°` : "未知";
        
        const entryHour = new Date(pass.entry.time).getHours();


            const now = new Date();
    const isCurrent = pass.entry.time && pass.exit.time && now >= pass.entry.time && now <= pass.exit.time;
        let rowClass = "";
        if (entryHour >= 19 || entryHour < 7) {
            rowClass = "night";  // 19:00-07:00，灰底白字
        } else {
            rowClass = "day";    // 其余时间，蓝底黄字
        }
        lang=currentLang
        document.getElementById('notesInfo').innerHTML = translations[lang].notesInfo; // 更新 notesInfo 内容

        const highestTime = pass.highest?.time ? new Date(pass.highest.time).toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : "未知时间";
        const highestAzimuth = typeof pass.highest?.azimuth === "number" ? `${pass.highest.azimuth.toFixed(2)}°` : "未知";
        const highestElevation = typeof pass.highest?.elevation === "number" ? `${pass.highest.elevation.toFixed(2)}°` : "未知";

        const exitTime = pass.exit?.time ? new Date(pass.exit.time).toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : "未知时间";
        const exitAzimuth = typeof pass.exit?.azimuth === "number" ? `${pass.exit.azimuth.toFixed(2)}°` : "未知";

        // Generate a placeholder for the canvas
        const chartId = `chart-${index}`;
        const chartHTML = `<canvas id="${chartId}" width="17" height="17"></canvas>`;

            // 如果是当前时间区间，则设置第一个格子的背景颜色为绿色
    const firstCellStyle = isCurrent ? 'style="background-color: green;"' : '';

//日历相关
    const eventTitle = `${satelliteName}  ${highestElevation}`;  // 事件标题为卫星名称+仰角
        const eventDate = pass.entry?.time ? new Date(pass.entry.time) : new Date();
        const startTime = eventDate.toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const endTime = pass.exit?.time ? new Date(pass.exit.time).toLocaleString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) : startTime;
        // Generate ICS link dynamically for each row
        const icsLink = generateICSLink(eventTitle, eventDate, startTime, endTime);
        console.log(icsLink)


        html += `
            <tr class="${rowClass}">
                 <td>
  <a href="javascript:void(0)" onclick="downloadICS('${eventTitle}', '${eventDate.toISOString()}', '${startTime}', '${endTime}')" style="color: #ffffbc;">
    ${entrydate}
  </a>
</td>
                <td>${entryTime}, ${entryAzimuth}</td>
                <td>${highestTime}</td>
                <td>${highestAzimuth}</td>
                                <td ${firstCellStyle}><a href="point.html?index=${index + 1}" target="_blank" style="color: #ffffbc;">${highestElevation}${chartHTML}</a></td>
                <td>${exitTime}, ${exitAzimuth}</td>
            </tr>
        `;
    });

    html += `
        </tbody>
    </table>
    `;

    // Append the HTML to the page
    document.getElementById('passInfo').innerHTML = html;

    // Now that the table is added, draw the trajectories
    setTimeout(() => {
        groupedPasses.forEach((pass, index) => {
            const canvas = document.getElementById(`chart-${index}`);
            if (canvas) {
                const ctx = canvas.getContext('2d');
                if (ctx) {
                    drawTrajectory(ctx, pass);
                }
            }
        });
    }, 0);

    return html;
}
//日历相关
function generateICSLink(eventTitle, eventDate, startTime, endTime) {
    const startDateTime = formatDateToICS(eventDate, startTime);
    const endDateTime = formatDateToICS(eventDate, endTime);
    console.log(startTime,startDateTime)

    const icsContent = `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Your Company//NONSGML v1.0//EN
BEGIN:VEVENT
SUMMARY:${eventTitle}
DTSTART:${startDateTime}
DTEND:${endDateTime}
UID:${generateUID()}
STATUS:CONFIRMED
BEGIN:VALARM
TRIGGER:-PT10M
DESCRIPTION:Reminder
ACTION:DISPLAY
END:VALARM
END:VEVENT
END:VCALENDAR`;

    const blob = new Blob([icsContent], { type: 'text/calendar' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `${eventTitle}.ics`;  // Download the ICS file
    return link.href;
}

function formatDateToICS(date, time) {
    // Create a new Date object based on the provided date
    const dt = new Date(date);

    // Split the provided time into hours and minutes
    const [hour, minute] = time.split(':');
    
    // Set the hours and minutes from the provided time
    dt.setHours(hour, minute);

    // Get the UTC time from the Date object (since it represents local time initially)
    const utcYear = dt.getUTCFullYear();
    const utcMonth = ('0' + (dt.getUTCMonth() + 1)).slice(-2);  // Month is 0-based
    const utcDay = ('0' + dt.getUTCDate()).slice(-2);
    const utcHour = ('0' + dt.getUTCHours()).slice(-2);
    const utcMinute = ('0' + dt.getUTCMinutes()).slice(-2);
    const utcSecond = ('0' + dt.getUTCSeconds()).slice(-2);

    // Return the formatted time in iCalendar format (UTC time with Z at the end)
    const formattedTime = `${utcYear}${utcMonth}${utcDay}T${utcHour}${utcMinute}${utcSecond}Z`;
    return formattedTime;
}

function generateUID() {
    return 'uid-' + Date.now();
}

// The function to trigger ICS download when a row is clicked
function downloadICS(eventTitle, eventDate, startTime, endTime) {
    const icsLink = generateICSLink(eventTitle, eventDate, startTime, endTime);
    const link = document.createElement('a');
    link.href = icsLink;
    link.click();
}

//日历相关结束
function drawTrajectory(ctx, selectedPass, scaleFactor = 0.17) { 
    const centerX = 50 * scaleFactor;
    const centerY = 50 * scaleFactor;
    const radius = 40 * scaleFactor;  // 缩放半径

    // 根据仰角调整半径
    const getRadiusForElevation = (elevation) => {
        return radius * (90 - elevation) / 90; // 仰角映射为半径比例
    };

    const entryRadius = getRadiusForElevation(0);
    const exitRadius = getRadiusForElevation(0);
    const highestRadius = getRadiusForElevation(selectedPass.highest?.elevation || 0);

    // 将方位角转换为绘图坐标
    const toCanvasCoords = (azimuth, distance) => {
        const angle = (90 - azimuth) * (Math.PI / 180); // 旋转方位角，0°指向北方
        const x = centerX + distance * Math.cos(angle);
        const y = centerY - distance * Math.sin(angle);
        return { x, y };
    };

    const { x: entryX, y: entryY } = toCanvasCoords(selectedPass.entry?.azimuth, entryRadius);
    const { x: exitX, y: exitY } = toCanvasCoords(selectedPass.exit?.azimuth, exitRadius);
    const { x: highestX, y: highestY } = toCanvasCoords(selectedPass.highest?.azimuth, highestRadius);

        // Draw black circle around the trajectory
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);  // Outer circle
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 1;
    ctx.stroke();



    // 绘制贝塞尔曲线连接轨迹点
    ctx.beginPath();
    ctx.moveTo(entryX, entryY);
    ctx.quadraticCurveTo(highestX, highestY, exitX, exitY);
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 1;
    ctx.stroke();
}


document.addEventListener('click', function(event) {
    const searchInput = document.getElementById('searchInput');
    const dropdown = document.getElementById('satelliteDropdown');

    // 检查点击目标是否是输入框或下拉列表的一部分
    if (!searchInput.contains(event.target) && !dropdown.contains(event.target)) {
        dropdown.style.display = 'none'; // 隐藏下拉菜单
    }
});



    </script>

    <script async src="https://umami.xanyi.eu.org/script.js" data-website-id="496abb71-e440-42cf-9b88-4593e8942949"></script>
</body>
</html>
